/*
 * pcd8544.c
 * Модуль для работы с дисплеями на базе контроллера PCD8544.
 */ 

// the memory buffer for the LCD
uint8_t display_buffer[DISPLAY_WIDTH * DISPLAY_PAGES] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFC, 0xFE, 0xFF, 0xFC, 0xE0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8,
0xF8, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x80, 0xC0, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x7F,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC7, 0xC7, 0x87, 0x8F, 0x9F, 0x9F, 0xFF, 0xFF, 0xFF,
0xC1, 0xC0, 0xE0, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFC, 0xFC, 0xFC, 0xFE, 0xFE, 0xFE,
0xFC, 0xFC, 0xF8, 0xF8, 0xF0, 0xE0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x80, 0xC0, 0xE0, 0xF1, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x1F, 0x0F, 0x0F, 0x87,
0xE7, 0xFF, 0xFF, 0xFF, 0x1F, 0x1F, 0x3F, 0xF9, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xFD, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x0F, 0x07, 0x01, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0xF0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
0x7E, 0x3F, 0x3F, 0x0F, 0x1F, 0xFF, 0xFF, 0xFF, 0xFC, 0xF0, 0xE0, 0xF1, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFC, 0xF0, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x01,
0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0F, 0x1F, 0x3F, 0x7F, 0x7F,
0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x1F, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

#ifdef PCD8544_SOFTWARE
	void pcd8544_send(uint8_t data) {
		for (uint8_t i = 0; i < 8; i++) {
			PCD8544_SCK_PORT &= ~PCD8544_SCK;
			if (data & 0x80) {
				PCD8544_MOSI_PORT |= PCD8544_MOSI;
			} else {
				PCD8544_MOSI_PORT &= ~PCD8544_MOSI;
			}
			data <<= 1;
			PCD8544_SCK_PORT |= PCD8544_SCK;
		}
	}
#else
	void pcd8544_send(uint8_t data) {
		SPDR = data;
		while (~(SPSR)&(1<<SPIF));
	}
#endif

// Инициализирует дисплей
void display_init(uint8_t bias) {
	PCD8544_MOSI_DDR |= (1 << PCD8544_MOSI_PIN_NUM);
	PCD8544_SCK_DDR |= (1 << PCD8544_SCK_PIN_NUM);
	#ifndef PCD8544_SOFTWARE
		// SS and MISO ports
		DDRB |= (1<<PB2); DDRB &= ~(1<<PB4);
		PORTB |= (1<<PB2); PORTB &= ~(1<<PB4);
		// Enable SPI
		SPCR = (1<<SPE);
		// Master mode
		SPCR |= (1<<MSTR);
		// MSB first
		SPCR &= ~(1<<DORD);
		// SPI mode 3
		SPCR |= (1<<CPOL)|(1<<CPHA);
		// SPI_CLOCK_DIV8
		SPCR |= (1<<SPR0); SPCR &= ~(1<<SPR1);
		SPSR |= (1<<SPI2X);
	#endif
	PCD8544_RESET_PIN_DDR |= (1 << PCD8544_RESET_PIN_NUM);
	PCD8544_SCE_DDR |= (1 << PCD8544_SCE_PIN_NUM);
	PCD8544_DC_DDR |= (1 << PCD8544_DC_PIN_NUM);
	PCD8544_RESET_PORT &= ~PCD8544_RESET;
	_delay_us(500);
	PCD8544_RESET_PORT |= PCD8544_RESET;
	display_cmd(PCD8544_FUNCTIONSET | PCD8544_EXTENDEDINSTRUCTION);
	display_cmd(PCD8544_SETBIAS | bias);
	display_cmd(PCD8544_SETTEMP);
	display_cmd(PCD8544_FUNCTIONSET);
	display_cmd(PCD8544_DISPLAYCONTROL | PCD8544_DISPLAYNORMAL);
}

void display_cmd(uint8_t data) {
	PCD8544_DC_PORT &= ~PCD8544_DC;
	PCD8544_SCE_PORT &= ~PCD8544_SCE;
	pcd8544_send(data);
	PCD8544_SCE_PORT |= PCD8544_SCE;
}

void display_data(uint8_t data) {
	PCD8544_DC_PORT |= PCD8544_DC;
	PCD8544_SCE_PORT &= ~PCD8544_SCE;
	pcd8544_send(data);
	PCD8544_SCE_PORT |= PCD8544_SCE;
}

// Установка уровня контраста
void display_contrast(uint8_t contrast) {
	if(contrast > 0x7f)
		contrast = 0x7f;
	display_cmd(PCD8544_FUNCTIONSET | PCD8544_EXTENDEDINSTRUCTION);
	display_cmd(PCD8544_SETVOP | contrast); 
	display_cmd(PCD8544_FUNCTIONSET);
}

/* Очищает экран, устанавливает курсор в левый верхний угол */
void display_clear(uint8_t color) {
	if(color==BLACK) color = 0xff;
	else color = 0x00;
	memset(display_buffer, color, DISPLAY_WIDTH * DISPLAY_PAGES);
}

/* Обновляет изображение на экране */
void display_update(uint8_t invert) {
	for(uint8_t page = 0; page < DISPLAY_PAGES; page++) {
		display_cmd(PCD8544_SETYADDR | page);
		display_cmd(PCD8544_SETXADDR | 0);
		for (uint8_t col = 0; col < DISPLAY_WIDTH; col++) {
			if(invert==true) {
				display_data(~display_buffer[(DISPLAY_WIDTH*page)+col]);
			} else {
				display_data(display_buffer[(DISPLAY_WIDTH*page)+col]);
			}
		}
	}
	display_cmd(PCD8544_SETYADDR);
}

/* Рисует пиксель на экране */
void display_drawPixel(uint8_t x, uint8_t y, uint8_t color) {
	if ((x < 0) || (x >= DISPLAY_WIDTH) || (y < 0) || (y >= DISPLAY_HEIGHT))
		return;
	if(color==BLACK)
		display_buffer[x+(y/8)*DISPLAY_WIDTH] |= _BV(y%8);
	else
		display_buffer[x+(y/8)*DISPLAY_WIDTH] &= ~_BV(y%8);
}

/* Получает значение цвета пикселя с экрана */
uint8_t display_getPixel(uint8_t x, uint8_t y) {
	if ((x < 0) || (x >= DISPLAY_WIDTH) || (y < 0) || (y >= DISPLAY_HEIGHT))
		return 0;
	return (display_buffer[x+(y/8)*DISPLAY_WIDTH] >> (y%8)) & 0x10;
}
